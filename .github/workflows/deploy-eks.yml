name: Build & Deploy to EKS (ECR + OIDC)

on:
  push:
    branches: ["main"] # main 브랜치에 push가 발생하면 자동으로 실행
  workflow_dispatch: # GitHub Actions 화면에서 버튼 눌러서 수동 실행 가능 (Actions 탭에서 해당 workflow 들어가면 Run workflow 버튼이 생김)

permissions: # 이 workflow가 GitHub 안에서 무엇을 할 수 있는지 정하는 최소 권한 설정
  id-token: write   # GitHub Actions가 OIDC 토큰(JWT) 을 발급받을 수 있게 허용
  contents: read

env: # 이 workflow 전체에서 공통으로 쓰는 변수 선언 영역
  AWS_REGION: ap-northeast-2

  # ===== ECR =====
  ECR_REPOSITORY: my-spring-app

  # ===== EKS =====
  EKS_CLUSTER_NAME: demo-eks-cluster
  K8S_NAMESPACE: default
  K8S_DEPLOYMENT_NAME: spring-app
  K8S_CONTAINER_NAME: spring-app

jobs: # 이 workflow에서 실행할 작업들의 모음
  deploy:
    runs-on: ubuntu-latest

    steps: # job 안에서 실제로 실행되는 작업들의 순서 목록 (위에서 아래로 순서대로 실행)
      - name: Checkout
        uses: actions/checkout@v4 #현재 GitHub repository의 코드를 GitHub Actions runner(가상머신)에 복사(clone) 

      # OIDC로 AWS Role Assume (Terraform로 만든 Role ARN 넣기)
      - name: Configure AWS credentials (OIDC)
        uses: aws-actions/configure-aws-credentials@v4 # 
        with:
          role-to-assume: arn:aws:iam::586794453466:role/GitHubActions-ECR-EKS
          aws-region: ${{ env.AWS_REGION }}

# GitHub Actions가 OIDC 토큰을 만든다
# AWS STS에 요청한다
# Terraform으로 만든 IAM Role
# (GitHubActions-ECR-EKS)을 runner 서버에 Assume
# runner 서버가 임시 AWS 로그인 완료*

      - name: Login to Amazon ECR
        id: ecr-login
        uses: aws-actions/amazon-ecr-login@v2
#runner 위에서 실행중인 docker가 AWS ECR에 로그인

      # 이미지 태그: 커밋 SHA(고정) + latest(편의) 
      - name: Build, tag, and push image to ECR
        env:
          ECR_REGISTRY: ${{ steps.ecr-login.outputs.registry }} # steps.ecr-login을 하면 outputs.registry값이 나옴, ECR 주소(레지스트리 주소)
          IMAGE_TAG_SHA: ${{ github.sha }} # 이번 workflow를 실행시킨 git 커밋의 SHA 값 (태그로 사용 예정)
        run: | # 리눅스 쉘(bash) 명령어를 여러 줄로 실행하겠다
          set -euo pipefail # 파이프(|)로 연결된 명령 중 하나라도 실패하면, 전체를 실패로 처리해라

          IMAGE_URI_SHA="${ECR_REGISTRY}/${ECR_REPOSITORY}:${IMAGE_TAG_SHA}" 
          IMAGE_URI_LATEST="${ECR_REGISTRY}/${ECR_REPOSITORY}:latest"  

          echo "Build -> ${IMAGE_URI_SHA}"
          docker build dockerfile -t "${IMAGE_URI_SHA}" -t "${IMAGE_URI_LATEST}" . # 현재 디렉토리(.)의 Dockerfile로 이미지 생성, 태그 값은 정확한 버전 (불변) 및 최신 버전으로 하여 이미지 생성

          echo "Push -> ${IMAGE_URI_SHA}"
          docker push "${IMAGE_URI_SHA}" # runner 서버에 만든 이미지를 ECR(원격 저장소)에 업로드
          docker push "${IMAGE_URI_LATEST}" # runner 서버에 만든 이미지를 ECR(원격 저장소)에 업로드

          echo "IMAGE_URI_SHA=${IMAGE_URI_SHA}" >> $GITHUB_ENV

      # kubectl 사용을 위해 kubeconfig 갱신
      - name: Update kubeconfig
        run: | # 리눅스 쉘(bash) 명령어를 여러 줄로 실행하겠다
          set -euo pipefail
          aws eks update-kubeconfig \ # kubectl 이 어느 리전, 클러스터에, 어떤 권한으로 접근할지 적혀 있는 설정 파일
            --region "${AWS_REGION}" \
            --name "${EKS_CLUSTER_NAME}"



      - name: Apply Kubernetes manifests
        run: |
          set -euo pipefail
          kubectl -n "${K8S_NAMESPACE}" apply -f k8s/ # runner가 k8s/deployment.yaml, service.yaml을 쿠버네티스 API 서버에 전달

      # 배포: Deployment의 컨테이너 이미지를 커밋SHA 태그로 바꿔서 롤링 업데이트
      - name: Deploy to EKS (set image)
        run: |
          set -euo pipefail

          kubectl -n "${K8S_NAMESPACE}" set image deployment/"${K8S_DEPLOYMENT_NAME}" \
            "${K8S_CONTAINER_NAME}"="${IMAGE_URI_SHA}"

          kubectl -n "${K8S_NAMESPACE}" rollout status deployment/"${K8S_DEPLOYMENT_NAME}" --timeout=180s

      # (옵션) 배포 결과 요약
      - name: Show resources
        if: always()
        run: |
          kubectl -n "${K8S_NAMESPACE}" get deploy,"po" -o wide

      